# Daily Algorithms Tutor - Concept + Practice

## Purpose
Provides structured daily practice for computer science fundamentals through concept introduction, examples, and three rounds of progressive Q&A. Builds algorithmic thinking through spaced repetition.

## Use Cases
- CS fundamentals review for interviews
- Algorithm and data structure learning
- Daily skill maintenance for engineers
- Teaching algorithmic thinking to beginners

## Instructions
1. Paste this prompt to start a daily algorithm lesson
2. Read the concept introduction and example
3. Answer three progressive questions (increasing difficulty)
4. Receive feedback and corrections after each answer
5. Review "Topics to review" summary at end
6. Session takes ~10-15 minutes

---

## The Prompt

```text
Imagine you're a computer science tutor running a daily micro-lesson.

Protocol for **today**:
1. Introduce **one core algorithmic concept** (e.g., Big-O, recursion, sorting, searching, trees, graphs, DP, etc.).
2. Explain it in **simple, precise terms**, with at least one concrete example.
3. Then run **3 rounds** of Q&A:

   For each round:
   - Ask me one question about the concept (increasing difficulty each round).
   - Wait for my answer.
   - Evaluate my answer:
     - What I got right.
     - What I missed or misunderstood.
   - Offer a corrected or improved answer.
   - Then move to the next question.

Constraints:
- Keep the entire session within ~10â€“15 minutes of reading/thinking time.
- Use plain language but don't oversimplify the math or logic.
- Track where I seem confused and briefly note it at the end as "Topics to review."
```

---

## Customization Notes

**Concept Coverage** (can request specific areas):
- **Fundamentals**: Big-O notation, recursion, iteration, space/time complexity
- **Data Structures**: Arrays, linked lists, stacks, queues, hash tables, trees, graphs, heaps
- **Algorithms**: Sorting (quicksort, mergesort, heapsort), searching (binary search, DFS, BFS)
- **Advanced**: Dynamic programming, greedy algorithms, backtracking, divide-and-conquer
- **Patterns**: Two pointers, sliding window, fast/slow pointers, merge intervals

**Difficulty Adjustment**:
- Beginner: Focus on understanding concepts and simple examples
- Intermediate: Include complexity analysis and edge cases
- Advanced: Optimization challenges and variant problems

**Question Types**:
- Conceptual: "Explain when to use..."
- Analytical: "What's the time complexity of..."
- Applied: "How would you solve..."
- Comparative: "What's the difference between... and..."

---

## Recommended Improvements

### Potential Enhancements
1. **Progress Tracking**: Maintain concept mastery scores across sessions
2. **Adaptive Difficulty**: Automatically adjust based on answer quality
3. **Code Practice**: Include actual coding exercises, not just verbal Q&A
4. **Visualization**: ASCII diagrams or step-by-step execution traces
5. **Interview Prep Mode**: Structure questions like real technical interviews
6. **Concept Dependencies**: Map prerequisite concepts and suggest learning paths
7. **Spaced Repetition**: Revisit weak areas based on forgetting curve

### Questions for Discussion
- Should this integrate with LeetCode or similar platforms for code execution?
- Add a "deep dive mode" for 30-minute extended sessions?
- Include peer comparison or difficulty percentiles?
- Support language-specific implementations (Python, JavaScript, Go, Rust)?
- Add "interview simulation" where AI acts as interviewer with follow-ups?
- Track long-term progress with concept mastery dashboard?
